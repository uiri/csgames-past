/* This file was generated by SableCC ( http://sablecc.org ). */

package language_minilang;

import java.io.*;
import java.util.*;

public class Parser {

  private final Lexer lexer;
  private final ParseStack stack = new ParseStack();

  public Parser(Reader reader) {
    this.lexer = new Lexer(reader);
  }

  public Node parse()
      throws ParserException, LexerException, IOException {

    Node tree = null;
    while(tree == null) {
      tree = stack.getState().apply(this);
    }

    return tree;
  }

  ParseStack getStack() {
    return this.stack;
  }

  private LinkedList<Token> lookList = new LinkedList<Token>();

  Token look(int distance)
      throws LexerException, IOException {
    while(lookList.size() < distance) {
      lookList.addLast(lexer.next());
    }
    return lookList.get(distance - 1);
  }

  void shift()
      throws ParserException, LexerException, IOException {
    Token token;
    if(lookList.size() > 0) {
      token = lookList.removeFirst();
    }
    else {
      token = lexer.next();
    }
    stack.push(token, stack.getState().getTarget(token));
  }
}

class ParseStack {
  private ParseStackEntry stack = new ParseStackEntry(null, null, L_0.instance);
  private ParseStackEntry freeList;

  void push(Node node, LRState state) {
    ParseStackEntry entry;
    if(freeList != null) {
      entry = freeList;
      freeList = freeList.previous;
      entry.set(stack, node, state);
    }
    else {
      entry = new ParseStackEntry(stack, node, state);
    }
    stack = entry;
  }

  LRState getState() {
    return stack.state;
  }

  Node pop() {
    Node node = stack.node;
    ParseStackEntry entry = stack;
    stack = stack.previous;
    entry.set(freeList, null, null);
    freeList = entry;
    return node;
  }

  private static class ParseStackEntry {
    ParseStackEntry previous;
    Node node;
    LRState state;

    ParseStackEntry(
        ParseStackEntry previous,
        Node node,
        LRState state) {
     this.previous = previous;
     this.node = node;
     this.state = state;
    }

    void set(
        ParseStackEntry previous,
        Node node,
        LRState state) {
     this.previous = previous;
     this.node = node;
     this.state = state;
   }
  }
}

abstract class LRState {

  abstract Node apply(Parser parser)
      throws ParserException, LexerException, IOException;
  abstract LRState getTarget(Node node)
      throws ParserException, LexerException, IOException;
}

class L_0
    extends LRState {

  static final L_0 instance = new L_0();

  private L_0() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      parser.shift();
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    case T_Prog:
      return L_10.instance;
    case T_Stmt:
      return L_8.instance;
    default:
      switch(node.getInternalType()) {
        case T_$0:
          return L_1.instance;
        case T_$1:
          return L_5.instance;
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_1
    extends LRState {

  static final L_1 instance = new L_1();

  private L_1() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      parser.shift();
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    case T_Expr:
      return L_4.instance;
    default:
      switch(node.getInternalType()) {
        case T_Int:
          return L_2.instance;
        case T_Str:
          return L_3.instance;
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_2
    extends LRState {

  static final L_2 instance = new L_2();

  private L_2() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      ParseStack stack = parser.getStack();

      NInt lInt = (NInt) stack.pop();

      NExpr_Int lExpr_Int = new NExpr_Int(-1, -1, lInt);
      stack.push(lExpr_Int, stack.getState().getTarget(lExpr_Int));
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_3
    extends LRState {

  static final L_3 instance = new L_3();

  private L_3() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      ParseStack stack = parser.getStack();

      NStr lStr = (NStr) stack.pop();

      NExpr_Str lExpr_Str = new NExpr_Str(-1, -1, lStr);
      stack.push(lExpr_Str, stack.getState().getTarget(lExpr_Str));
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_4
    extends LRState {

  static final L_4 instance = new L_4();

  private L_4() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      ParseStack stack = parser.getStack();

      NExpr lExpr = (NExpr) stack.pop();
      N$0 l$0 = (N$0) stack.pop();

      NStmt_Print lStmt_Print = new NStmt_Print(-1, -1, l$0, lExpr);
      stack.push(lStmt_Print, stack.getState().getTarget(lStmt_Print));
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_5
    extends LRState {

  static final L_5 instance = new L_5();

  private L_5() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      parser.shift();
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    case T_Prog:
      return L_6.instance;
    case T_Stmt:
      return L_8.instance;
    default:
      switch(node.getInternalType()) {
        case T_$0:
          return L_1.instance;
        case T_$1:
          return L_5.instance;
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_6
    extends LRState {

  static final L_6 instance = new L_6();

  private L_6() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      parser.shift();
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        case T_$2:
          return L_7.instance;
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_7
    extends LRState {

  static final L_7 instance = new L_7();

  private L_7() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      ParseStack stack = parser.getStack();

      N$2 l$2 = (N$2) stack.pop();
      NProg lProg = (NProg) stack.pop();
      N$1 l$1 = (N$1) stack.pop();

      NStmt_Stmts lStmt_Stmts = new NStmt_Stmts(-1, -1, l$1, lProg, l$2);
      stack.push(lStmt_Stmts, stack.getState().getTarget(lStmt_Stmts));
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_8
    extends LRState {

  static final L_8 instance = new L_8();

  private L_8() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    // LR(1) decisions
    if (parser.look(1).getInternalType() == Node.InternalType.T_$0) {
      parser.shift();
      return null;
    }
    if (parser.look(1).getInternalType() == Node.InternalType.T_$1) {
      parser.shift();
      return null;
    }
    if ((parser.look(1).getInternalType() == Node.InternalType.TEnd || parser.look(1).getInternalType() == Node.InternalType.T_$2)) {
      ParseStack stack = parser.getStack();

      NStmt lStmt = (NStmt) stack.pop();

      NProg_$2 lProg_$2 = new NProg_$2(-1, -1, lStmt);
      stack.push(lProg_$2, stack.getState().getTarget(lProg_$2));
      return null;
    }
    parser.shift();
    return null;
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    case T_Prog:
      return L_9.instance;
    case T_Stmt:
      return L_8.instance;
    default:
      switch(node.getInternalType()) {
        case T_$0:
          return L_1.instance;
        case T_$1:
          return L_5.instance;
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_9
    extends LRState {

  static final L_9 instance = new L_9();

  private L_9() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      ParseStack stack = parser.getStack();

      NProg lProg = (NProg) stack.pop();
      NStmt lStmt = (NStmt) stack.pop();

      NProg_$1 lProg_$1 = new NProg_$1(-1, -1, lStmt, lProg);
      stack.push(lProg_$1, stack.getState().getTarget(lProg_$1));
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_10
    extends LRState {

  static final L_10 instance = new L_10();

  private L_10() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      parser.shift();
      return null;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        case TEnd:
          return L_11.instance;
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}

class L_11
    extends LRState {

  static final L_11 instance = new L_11();

  private L_11() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

    // LR(0) decisions
    {
      ParseStack stack = parser.getStack();

      End l$end = (End) stack.pop();
      NProg l$1 = (NProg) stack.pop();

      return l$1;
    }
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
    default:
      switch(node.getInternalType()) {
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}
