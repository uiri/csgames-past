/* This file was generated by SableCC (http://www.sablecc.org/). */

package org.sablecc.sablecc.intermediate.syntax3.analysis;

import java.util.*;
import org.sablecc.sablecc.intermediate.syntax3.node.*;

public class ReversedDepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getEOF().apply(this);
        node.getPIntermediateRepresentation().apply(this);
        outStart(node);
    }

    public void inAIntermediateRepresentation(AIntermediateRepresentation node)
    {
        defaultIn(node);
    }

    public void outAIntermediateRepresentation(AIntermediateRepresentation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntermediateRepresentation(AIntermediateRepresentation node)
    {
        inAIntermediateRepresentation(node);
        if(node.getParser() != null)
        {
            node.getParser().apply(this);
        }
        if(node.getLexer() != null)
        {
            node.getLexer().apply(this);
        }
        if(node.getLanguage() != null)
        {
            node.getLanguage().apply(this);
        }
        outAIntermediateRepresentation(node);
    }

    public void inALanguage(ALanguage node)
    {
        defaultIn(node);
    }

    public void outALanguage(ALanguage node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALanguage(ALanguage node)
    {
        inALanguage(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outALanguage(node);
    }

    public void inALexer(ALexer node)
    {
        defaultIn(node);
    }

    public void outALexer(ALexer node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexer(ALexer node)
    {
        inALexer(node);
        {
            List<PTokenInvestigator> copy = new ArrayList<PTokenInvestigator>(node.getTokenInvestigators());
            Collections.reverse(copy);
            for(PTokenInvestigator e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PContext> copy = new ArrayList<PContext>(node.getContexts());
            Collections.reverse(copy);
            for(PContext e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PTokenSelector> copy = new ArrayList<PTokenSelector>(node.getTokenSelectors());
            Collections.reverse(copy);
            for(PTokenSelector e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PToken> copy = new ArrayList<PToken>(node.getTokens());
            Collections.reverse(copy);
            for(PToken e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PGroup> copy = new ArrayList<PGroup>(node.getGroups());
            Collections.reverse(copy);
            for(PGroup e : copy)
            {
                e.apply(this);
            }
        }
        outALexer(node);
    }

    public void inAGroup(AGroup node)
    {
        defaultIn(node);
    }

    public void outAGroup(AGroup node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGroup(AGroup node)
    {
        inAGroup(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAGroup(node);
    }

    public void inANormalToken(ANormalToken node)
    {
        defaultIn(node);
    }

    public void outANormalToken(ANormalToken node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANormalToken(ANormalToken node)
    {
        inANormalToken(node);
        {
            List<TString> copy = new ArrayList<TString>(node.getInvestigators());
            Collections.reverse(copy);
            for(TString e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TString> copy = new ArrayList<TString>(node.getGroups());
            Collections.reverse(copy);
            for(TString e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getPublic() != null)
        {
            node.getPublic().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outANormalToken(node);
    }

    public void inASelectionToken(ASelectionToken node)
    {
        defaultIn(node);
    }

    public void outASelectionToken(ASelectionToken node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASelectionToken(ASelectionToken node)
    {
        inASelectionToken(node);
        if(node.getSelector() != null)
        {
            node.getSelector().apply(this);
        }
        if(node.getPublic() != null)
        {
            node.getPublic().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outASelectionToken(node);
    }

    public void inATokenSelector(ATokenSelector node)
    {
        defaultIn(node);
    }

    public void outATokenSelector(ATokenSelector node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokenSelector(ATokenSelector node)
    {
        inATokenSelector(node);
        {
            List<TString> copy = new ArrayList<TString>(node.getTokens());
            Collections.reverse(copy);
            for(TString e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getArgument() != null)
        {
            node.getArgument().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outATokenSelector(node);
    }

    public void inATokenInvestigator(ATokenInvestigator node)
    {
        defaultIn(node);
    }

    public void outATokenInvestigator(ATokenInvestigator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokenInvestigator(ATokenInvestigator node)
    {
        inATokenInvestigator(node);
        if(node.getArgument() != null)
        {
            node.getArgument().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outATokenInvestigator(node);
    }

    public void inAContext(AContext node)
    {
        defaultIn(node);
    }

    public void outAContext(AContext node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAContext(AContext node)
    {
        inAContext(node);
        {
            List<PLexerAction> copy = new ArrayList<PLexerAction>(node.getLexerActions());
            Collections.reverse(copy);
            for(PLexerAction e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getLexerAutomaton() != null)
        {
            node.getLexerAutomaton().apply(this);
        }
        if(node.getAlphabet() != null)
        {
            node.getAlphabet().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAContext(node);
    }

    public void inAAlphabet(AAlphabet node)
    {
        defaultIn(node);
    }

    public void outAAlphabet(AAlphabet node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAlphabet(AAlphabet node)
    {
        inAAlphabet(node);
        {
            List<PInterval> copy = new ArrayList<PInterval>(node.getIntervals());
            Collections.reverse(copy);
            for(PInterval e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PSymbol> copy = new ArrayList<PSymbol>(node.getSymbols());
            Collections.reverse(copy);
            for(PSymbol e : copy)
            {
                e.apply(this);
            }
        }
        outAAlphabet(node);
    }

    public void inASymbol(ASymbol node)
    {
        defaultIn(node);
    }

    public void outASymbol(ASymbol node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASymbol(ASymbol node)
    {
        inASymbol(node);
        {
            List<PInterval> copy = new ArrayList<PInterval>(node.getIntervals());
            Collections.reverse(copy);
            for(PInterval e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outASymbol(node);
    }

    public void inAInterval(AInterval node)
    {
        defaultIn(node);
    }

    public void outAInterval(AInterval node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAInterval(AInterval node)
    {
        inAInterval(node);
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        outAInterval(node);
    }

    public void inALexerAutomaton(ALexerAutomaton node)
    {
        defaultIn(node);
    }

    public void outALexerAutomaton(ALexerAutomaton node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexerAutomaton(ALexerAutomaton node)
    {
        inALexerAutomaton(node);
        {
            List<TString> copy = new ArrayList<TString>(node.getMarkers());
            Collections.reverse(copy);
            for(TString e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PLexerState> copy = new ArrayList<PLexerState>(node.getLexerStates());
            Collections.reverse(copy);
            for(PLexerState e : copy)
            {
                e.apply(this);
            }
        }
        outALexerAutomaton(node);
    }

    public void inAProgressLexerState(AProgressLexerState node)
    {
        defaultIn(node);
    }

    public void outAProgressLexerState(AProgressLexerState node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgressLexerState(AProgressLexerState node)
    {
        inAProgressLexerState(node);
        if(node.getEndExpected() != null)
        {
            node.getEndExpected().apply(this);
        }
        {
            List<PInterval> copy = new ArrayList<PInterval>(node.getExpectedIntervals());
            Collections.reverse(copy);
            for(PInterval e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PLexerTransition> copy = new ArrayList<PLexerTransition>(node.getLexerTransitions());
            Collections.reverse(copy);
            for(PLexerTransition e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getMarker() != null)
        {
            node.getMarker().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAProgressLexerState(node);
    }

    public void inATokenLexerState(ATokenLexerState node)
    {
        defaultIn(node);
    }

    public void outATokenLexerState(ATokenLexerState node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokenLexerState(ATokenLexerState node)
    {
        inATokenLexerState(node);
        if(node.getToken() != null)
        {
            node.getToken().apply(this);
        }
        if(node.getMarker() != null)
        {
            node.getMarker().apply(this);
        }
        if(node.getBackCount() != null)
        {
            node.getBackCount().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outATokenLexerState(node);
    }

    public void inALexerTransition(ALexerTransition node)
    {
        defaultIn(node);
    }

    public void outALexerTransition(ALexerTransition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexerTransition(ALexerTransition node)
    {
        inALexerTransition(node);
        if(node.getTarget() != null)
        {
            node.getTarget().apply(this);
        }
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        outALexerTransition(node);
    }

    public void inAAcceptLexerAction(AAcceptLexerAction node)
    {
        defaultIn(node);
    }

    public void outAAcceptLexerAction(AAcceptLexerAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAcceptLexerAction(AAcceptLexerAction node)
    {
        inAAcceptLexerAction(node);
        if(node.getToken() != null)
        {
            node.getToken().apply(this);
        }
        outAAcceptLexerAction(node);
    }

    public void inAIgnoreLexerAction(AIgnoreLexerAction node)
    {
        defaultIn(node);
    }

    public void outAIgnoreLexerAction(AIgnoreLexerAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIgnoreLexerAction(AIgnoreLexerAction node)
    {
        inAIgnoreLexerAction(node);
        if(node.getToken() != null)
        {
            node.getToken().apply(this);
        }
        outAIgnoreLexerAction(node);
    }

    public void inARejectLexerAction(ARejectLexerAction node)
    {
        defaultIn(node);
    }

    public void outARejectLexerAction(ARejectLexerAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARejectLexerAction(ARejectLexerAction node)
    {
        inARejectLexerAction(node);
        if(node.getToken() != null)
        {
            node.getToken().apply(this);
        }
        outARejectLexerAction(node);
    }

    public void inAParseLexerAction(AParseLexerAction node)
    {
        defaultIn(node);
    }

    public void outAParseLexerAction(AParseLexerAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParseLexerAction(AParseLexerAction node)
    {
        inAParseLexerAction(node);
        if(node.getStart() != null)
        {
            node.getStart().apply(this);
        }
        if(node.getToken() != null)
        {
            node.getToken().apply(this);
        }
        outAParseLexerAction(node);
    }

    public void inATrueBoolean(ATrueBoolean node)
    {
        defaultIn(node);
    }

    public void outATrueBoolean(ATrueBoolean node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATrueBoolean(ATrueBoolean node)
    {
        inATrueBoolean(node);
        outATrueBoolean(node);
    }

    public void inAFalseBoolean(AFalseBoolean node)
    {
        defaultIn(node);
    }

    public void outAFalseBoolean(AFalseBoolean node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFalseBoolean(AFalseBoolean node)
    {
        inAFalseBoolean(node);
        outAFalseBoolean(node);
    }

    public void inAParser(AParser node)
    {
        defaultIn(node);
    }

    public void outAParser(AParser node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParser(AParser node)
    {
        inAParser(node);
        {
            List<PParserSelector> copy = new ArrayList<PParserSelector>(node.getParserSelectors());
            Collections.reverse(copy);
            for(PParserSelector e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PParserInvestigator> copy = new ArrayList<PParserInvestigator>(node.getParserInvestigators());
            Collections.reverse(copy);
            for(PParserInvestigator e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PStart> copy = new ArrayList<PStart>(node.getStarts());
            Collections.reverse(copy);
            for(PStart e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PParseProduction> copy = new ArrayList<PParseProduction>(node.getParseProductions());
            Collections.reverse(copy);
            for(PParseProduction e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PProduction> copy = new ArrayList<PProduction>(node.getProductions());
            Collections.reverse(copy);
            for(PProduction e : copy)
            {
                e.apply(this);
            }
        }
        outAParser(node);
    }

    public void inAProduction(AProduction node)
    {
        defaultIn(node);
    }

    public void outAProduction(AProduction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProduction(AProduction node)
    {
        inAProduction(node);
        {
            List<PAlternative> copy = new ArrayList<PAlternative>(node.getAlternatives());
            Collections.reverse(copy);
            for(PAlternative e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAProduction(node);
    }

    public void inAAlternative(AAlternative node)
    {
        defaultIn(node);
    }

    public void outAAlternative(AAlternative node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAlternative(AAlternative node)
    {
        inAAlternative(node);
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            Collections.reverse(copy);
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getPublic() != null)
        {
            node.getPublic().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAAlternative(node);
    }

    public void inAElement(AElement node)
    {
        defaultIn(node);
    }

    public void outAElement(AElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAElement(AElement node)
    {
        inAElement(node);
        if(node.getElementType() != null)
        {
            node.getElementType().apply(this);
        }
        if(node.getPublic() != null)
        {
            node.getPublic().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAElement(node);
    }

    public void inASingleElementType(ASingleElementType node)
    {
        defaultIn(node);
    }

    public void outASingleElementType(ASingleElementType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASingleElementType(ASingleElementType node)
    {
        inASingleElementType(node);
        if(node.getSingleType() != null)
        {
            node.getSingleType().apply(this);
        }
        outASingleElementType(node);
    }

    public void inAListElementType(AListElementType node)
    {
        defaultIn(node);
    }

    public void outAListElementType(AListElementType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAListElementType(AListElementType node)
    {
        inAListElementType(node);
        if(node.getListType() != null)
        {
            node.getListType().apply(this);
        }
        outAListElementType(node);
    }

    public void inAOneSingleType(AOneSingleType node)
    {
        defaultIn(node);
    }

    public void outAOneSingleType(AOneSingleType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOneSingleType(AOneSingleType node)
    {
        inAOneSingleType(node);
        if(node.getPublic() != null)
        {
            node.getPublic().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outAOneSingleType(node);
    }

    public void inAZeroOrOneSingleType(AZeroOrOneSingleType node)
    {
        defaultIn(node);
    }

    public void outAZeroOrOneSingleType(AZeroOrOneSingleType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAZeroOrOneSingleType(AZeroOrOneSingleType node)
    {
        inAZeroOrOneSingleType(node);
        if(node.getPublic() != null)
        {
            node.getPublic().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outAZeroOrOneSingleType(node);
    }

    public void inANumberListType(ANumberListType node)
    {
        defaultIn(node);
    }

    public void outANumberListType(ANumberListType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANumberListType(ANumberListType node)
    {
        inANumberListType(node);
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outANumberListType(node);
    }

    public void inAIntervalListType(AIntervalListType node)
    {
        defaultIn(node);
    }

    public void outAIntervalListType(AIntervalListType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntervalListType(AIntervalListType node)
    {
        inAIntervalListType(node);
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outAIntervalListType(node);
    }

    public void inAAtLeastListType(AAtLeastListType node)
    {
        defaultIn(node);
    }

    public void outAAtLeastListType(AAtLeastListType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAtLeastListType(AAtLeastListType node)
    {
        inAAtLeastListType(node);
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outAAtLeastListType(node);
    }

    public void inASeparatedNumberListType(ASeparatedNumberListType node)
    {
        defaultIn(node);
    }

    public void outASeparatedNumberListType(ASeparatedNumberListType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedNumberListType(ASeparatedNumberListType node)
    {
        inASeparatedNumberListType(node);
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicSeparator() != null)
        {
            node.getPublicSeparator().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outASeparatedNumberListType(node);
    }

    public void inASeparatedIntervalListType(ASeparatedIntervalListType node)
    {
        defaultIn(node);
    }

    public void outASeparatedIntervalListType(ASeparatedIntervalListType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedIntervalListType(ASeparatedIntervalListType node)
    {
        inASeparatedIntervalListType(node);
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getPublicSeparator() != null)
        {
            node.getPublicSeparator().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outASeparatedIntervalListType(node);
    }

    public void inASeparatedAtLeastListType(ASeparatedAtLeastListType node)
    {
        defaultIn(node);
    }

    public void outASeparatedAtLeastListType(ASeparatedAtLeastListType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedAtLeastListType(ASeparatedAtLeastListType node)
    {
        inASeparatedAtLeastListType(node);
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicSeparator() != null)
        {
            node.getPublicSeparator().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outASeparatedAtLeastListType(node);
    }

    public void inAParseProduction(AParseProduction node)
    {
        defaultIn(node);
    }

    public void outAParseProduction(AParseProduction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParseProduction(AParseProduction node)
    {
        inAParseProduction(node);
        {
            List<PRetainedElement> copy = new ArrayList<PRetainedElement>(node.getRetainedElements());
            Collections.reverse(copy);
            for(PRetainedElement e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PParseAlternative> copy = new ArrayList<PParseAlternative>(node.getParseAlternatives());
            Collections.reverse(copy);
            for(PParseAlternative e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAParseProduction(node);
    }

    public void inARetainedElement(ARetainedElement node)
    {
        defaultIn(node);
    }

    public void outARetainedElement(ARetainedElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARetainedElement(ARetainedElement node)
    {
        inARetainedElement(node);
        if(node.getElementType() != null)
        {
            node.getElementType().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outARetainedElement(node);
    }

    public void inAParseAlternative(AParseAlternative node)
    {
        defaultIn(node);
    }

    public void outAParseAlternative(AParseAlternative node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParseAlternative(AParseAlternative node)
    {
        inAParseAlternative(node);
        {
            List<PTransformation> copy = new ArrayList<PTransformation>(node.getTransformations());
            Collections.reverse(copy);
            for(PTransformation e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PParseElement> copy = new ArrayList<PParseElement>(node.getParseElements());
            Collections.reverse(copy);
            for(PParseElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAParseAlternative(node);
    }

    public void inAParseElement(AParseElement node)
    {
        defaultIn(node);
    }

    public void outAParseElement(AParseElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParseElement(AParseElement node)
    {
        inAParseElement(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAParseElement(node);
    }

    public void inATransformation(ATransformation node)
    {
        defaultIn(node);
    }

    public void outATransformation(ATransformation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATransformation(ATransformation node)
    {
        inATransformation(node);
        if(node.getValue() != null)
        {
            node.getValue().apply(this);
        }
        if(node.getRetainedElement() != null)
        {
            node.getRetainedElement().apply(this);
        }
        outATransformation(node);
    }

    public void inANullValue(ANullValue node)
    {
        defaultIn(node);
    }

    public void outANullValue(ANullValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANullValue(ANullValue node)
    {
        inANullValue(node);
        outANullValue(node);
    }

    public void inAReferenceValue(AReferenceValue node)
    {
        defaultIn(node);
    }

    public void outAReferenceValue(AReferenceValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReferenceValue(AReferenceValue node)
    {
        inAReferenceValue(node);
        if(node.getRetainedElement() != null)
        {
            node.getRetainedElement().apply(this);
        }
        if(node.getParseElement() != null)
        {
            node.getParseElement().apply(this);
        }
        outAReferenceValue(node);
    }

    public void inANewValue(ANewValue node)
    {
        defaultIn(node);
    }

    public void outANewValue(ANewValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANewValue(ANewValue node)
    {
        inANewValue(node);
        {
            List<PValue> copy = new ArrayList<PValue>(node.getValues());
            Collections.reverse(copy);
            for(PValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getAlternative() != null)
        {
            node.getAlternative().apply(this);
        }
        outANewValue(node);
    }

    public void inANumberValue(ANumberValue node)
    {
        defaultIn(node);
    }

    public void outANumberValue(ANumberValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANumberValue(ANumberValue node)
    {
        inANumberValue(node);
        {
            List<PListValue> copy = new ArrayList<PListValue>(node.getListValues());
            Collections.reverse(copy);
            for(PListValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outANumberValue(node);
    }

    public void inAIntervalValue(AIntervalValue node)
    {
        defaultIn(node);
    }

    public void outAIntervalValue(AIntervalValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntervalValue(AIntervalValue node)
    {
        inAIntervalValue(node);
        {
            List<PListValue> copy = new ArrayList<PListValue>(node.getListValues());
            Collections.reverse(copy);
            for(PListValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outAIntervalValue(node);
    }

    public void inAAtLeastValue(AAtLeastValue node)
    {
        defaultIn(node);
    }

    public void outAAtLeastValue(AAtLeastValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAtLeastValue(AAtLeastValue node)
    {
        inAAtLeastValue(node);
        {
            List<PListValue> copy = new ArrayList<PListValue>(node.getListValues());
            Collections.reverse(copy);
            for(PListValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outAAtLeastValue(node);
    }

    public void inASeparatedNumberValue(ASeparatedNumberValue node)
    {
        defaultIn(node);
    }

    public void outASeparatedNumberValue(ASeparatedNumberValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedNumberValue(ASeparatedNumberValue node)
    {
        inASeparatedNumberValue(node);
        {
            List<PListValue> copy = new ArrayList<PListValue>(node.getListValues());
            Collections.reverse(copy);
            for(PListValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicSeparator() != null)
        {
            node.getPublicSeparator().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outASeparatedNumberValue(node);
    }

    public void inASeparatedIntervalValue(ASeparatedIntervalValue node)
    {
        defaultIn(node);
    }

    public void outASeparatedIntervalValue(ASeparatedIntervalValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedIntervalValue(ASeparatedIntervalValue node)
    {
        inASeparatedIntervalValue(node);
        {
            List<PListValue> copy = new ArrayList<PListValue>(node.getListValues());
            Collections.reverse(copy);
            for(PListValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getPublicSeparator() != null)
        {
            node.getPublicSeparator().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outASeparatedIntervalValue(node);
    }

    public void inASeparatedAtLeastValue(ASeparatedAtLeastValue node)
    {
        defaultIn(node);
    }

    public void outASeparatedAtLeastValue(ASeparatedAtLeastValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedAtLeastValue(ASeparatedAtLeastValue node)
    {
        inASeparatedAtLeastValue(node);
        {
            List<PListValue> copy = new ArrayList<PListValue>(node.getListValues());
            Collections.reverse(copy);
            for(PListValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getPublicSeparator() != null)
        {
            node.getPublicSeparator().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getPublicUnit() != null)
        {
            node.getPublicUnit().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        outASeparatedAtLeastValue(node);
    }

    public void inAReferenceListValue(AReferenceListValue node)
    {
        defaultIn(node);
    }

    public void outAReferenceListValue(AReferenceListValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReferenceListValue(AReferenceListValue node)
    {
        inAReferenceListValue(node);
        if(node.getRetainedElement() != null)
        {
            node.getRetainedElement().apply(this);
        }
        if(node.getParseElement() != null)
        {
            node.getParseElement().apply(this);
        }
        outAReferenceListValue(node);
    }

    public void inAListReferenceListValue(AListReferenceListValue node)
    {
        defaultIn(node);
    }

    public void outAListReferenceListValue(AListReferenceListValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAListReferenceListValue(AListReferenceListValue node)
    {
        inAListReferenceListValue(node);
        if(node.getRetainedElement() != null)
        {
            node.getRetainedElement().apply(this);
        }
        if(node.getParseElement() != null)
        {
            node.getParseElement().apply(this);
        }
        outAListReferenceListValue(node);
    }

    public void inANewListValue(ANewListValue node)
    {
        defaultIn(node);
    }

    public void outANewListValue(ANewListValue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANewListValue(ANewListValue node)
    {
        inANewListValue(node);
        {
            List<PValue> copy = new ArrayList<PValue>(node.getValues());
            Collections.reverse(copy);
            for(PValue e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getAlternative() != null)
        {
            node.getAlternative().apply(this);
        }
        outANewListValue(node);
    }

    public void inAStart(AStart node)
    {
        defaultIn(node);
    }

    public void outAStart(AStart node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStart(AStart node)
    {
        inAStart(node);
        if(node.getParserAutomaton() != null)
        {
            node.getParserAutomaton().apply(this);
        }
        outAStart(node);
    }

    public void inAParserAutomaton(AParserAutomaton node)
    {
        defaultIn(node);
    }

    public void outAParserAutomaton(AParserAutomaton node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserAutomaton(AParserAutomaton node)
    {
        inAParserAutomaton(node);
        {
            List<PParserState> copy = new ArrayList<PParserState>(node.getParserStates());
            Collections.reverse(copy);
            for(PParserState e : copy)
            {
                e.apply(this);
            }
        }
        outAParserAutomaton(node);
    }

    public void inAParserState(AParserState node)
    {
        defaultIn(node);
    }

    public void outAParserState(AParserState node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserState(AParserState node)
    {
        inAParserState(node);
        {
            List<PParserTransition> copy = new ArrayList<PParserTransition>(node.getParserTransitions());
            Collections.reverse(copy);
            for(PParserTransition e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getDecision() != null)
        {
            node.getDecision().apply(this);
        }
        if(node.getInvestigator() != null)
        {
            node.getInvestigator().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAParserState(node);
    }

    public void inAParserInvestigator(AParserInvestigator node)
    {
        defaultIn(node);
    }

    public void outAParserInvestigator(AParserInvestigator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserInvestigator(AParserInvestigator node)
    {
        inAParserInvestigator(node);
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            Collections.reverse(copy);
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAParserInvestigator(node);
    }

    public void inANoLookDecision(ANoLookDecision node)
    {
        defaultIn(node);
    }

    public void outANoLookDecision(ANoLookDecision node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANoLookDecision(ANoLookDecision node)
    {
        inANoLookDecision(node);
        if(node.getAction() != null)
        {
            node.getAction().apply(this);
        }
        outANoLookDecision(node);
    }

    public void inALookDecision(ALookDecision node)
    {
        defaultIn(node);
    }

    public void outALookDecision(ALookDecision node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALookDecision(ALookDecision node)
    {
        inALookDecision(node);
        {
            List<PDepth> copy = new ArrayList<PDepth>(node.getDepths());
            Collections.reverse(copy);
            for(PDepth e : copy)
            {
                e.apply(this);
            }
        }
        outALookDecision(node);
    }

    public void inADepth(ADepth node)
    {
        defaultIn(node);
    }

    public void outADepth(ADepth node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADepth(ADepth node)
    {
        inADepth(node);
        {
            List<PChoice> copy = new ArrayList<PChoice>(node.getChoices());
            Collections.reverse(copy);
            for(PChoice e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getContext() != null)
        {
            node.getContext().apply(this);
        }
        if(node.getLookDepth() != null)
        {
            node.getLookDepth().apply(this);
        }
        outADepth(node);
    }

    public void inAChoice(AChoice node)
    {
        defaultIn(node);
    }

    public void outAChoice(AChoice node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAChoice(AChoice node)
    {
        inAChoice(node);
        if(node.getAction() != null)
        {
            node.getAction().apply(this);
        }
        {
            List<PCondition> copy = new ArrayList<PCondition>(node.getConditions());
            Collections.reverse(copy);
            for(PCondition e : copy)
            {
                e.apply(this);
            }
        }
        outAChoice(node);
    }

    public void inACondition(ACondition node)
    {
        defaultIn(node);
    }

    public void outACondition(ACondition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACondition(ACondition node)
    {
        inACondition(node);
        {
            List<PLookSymbol> copy = new ArrayList<PLookSymbol>(node.getLookSymbols());
            Collections.reverse(copy);
            for(PLookSymbol e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getLookDepth() != null)
        {
            node.getLookDepth().apply(this);
        }
        outACondition(node);
    }

    public void inALookSymbol(ALookSymbol node)
    {
        defaultIn(node);
    }

    public void outALookSymbol(ALookSymbol node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALookSymbol(ALookSymbol node)
    {
        inALookSymbol(node);
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        outALookSymbol(node);
    }

    public void inAShiftAction(AShiftAction node)
    {
        defaultIn(node);
    }

    public void outAShiftAction(AShiftAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAShiftAction(AShiftAction node)
    {
        inAShiftAction(node);
        if(node.getContext() != null)
        {
            node.getContext().apply(this);
        }
        outAShiftAction(node);
    }

    public void inAReduceAction(AReduceAction node)
    {
        defaultIn(node);
    }

    public void outAReduceAction(AReduceAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReduceAction(AReduceAction node)
    {
        inAReduceAction(node);
        if(node.getParseAlternative() != null)
        {
            node.getParseAlternative().apply(this);
        }
        outAReduceAction(node);
    }

    public void inASelectionAction(ASelectionAction node)
    {
        defaultIn(node);
    }

    public void outASelectionAction(ASelectionAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASelectionAction(ASelectionAction node)
    {
        inASelectionAction(node);
        {
            List<PExpectedSelection> copy = new ArrayList<PExpectedSelection>(node.getExpectedSelections());
            Collections.reverse(copy);
            for(PExpectedSelection e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getSelector() != null)
        {
            node.getSelector().apply(this);
        }
        outASelectionAction(node);
    }

    public void inATreeAction(ATreeAction node)
    {
        defaultIn(node);
    }

    public void outATreeAction(ATreeAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATreeAction(ATreeAction node)
    {
        inATreeAction(node);
        if(node.getParseAlternative() != null)
        {
            node.getParseAlternative().apply(this);
        }
        outATreeAction(node);
    }

    public void inATokenAction(ATokenAction node)
    {
        defaultIn(node);
    }

    public void outATokenAction(ATokenAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokenAction(ATokenAction node)
    {
        inATokenAction(node);
        if(node.getParseAlternative() != null)
        {
            node.getParseAlternative().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outATokenAction(node);
    }

    public void inAExpectedSelection(AExpectedSelection node)
    {
        defaultIn(node);
    }

    public void outAExpectedSelection(AExpectedSelection node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAExpectedSelection(AExpectedSelection node)
    {
        inAExpectedSelection(node);
        if(node.getParseAlternative() != null)
        {
            node.getParseAlternative().apply(this);
        }
        if(node.getParseProduction() != null)
        {
            node.getParseProduction().apply(this);
        }
        outAExpectedSelection(node);
    }

    public void inAParserSelector(AParserSelector node)
    {
        defaultIn(node);
    }

    public void outAParserSelector(AParserSelector node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserSelector(AParserSelector node)
    {
        inAParserSelector(node);
        {
            List<TString> copy = new ArrayList<TString>(node.getParseProductions());
            Collections.reverse(copy);
            for(TString e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            Collections.reverse(copy);
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAParserSelector(node);
    }

    public void inATokenParserTransition(ATokenParserTransition node)
    {
        defaultIn(node);
    }

    public void outATokenParserTransition(ATokenParserTransition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokenParserTransition(ATokenParserTransition node)
    {
        inATokenParserTransition(node);
        if(node.getTarget() != null)
        {
            node.getTarget().apply(this);
        }
        if(node.getToken() != null)
        {
            node.getToken().apply(this);
        }
        outATokenParserTransition(node);
    }

    public void inAProductionParserTransition(AProductionParserTransition node)
    {
        defaultIn(node);
    }

    public void outAProductionParserTransition(AProductionParserTransition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProductionParserTransition(AProductionParserTransition node)
    {
        inAProductionParserTransition(node);
        if(node.getTarget() != null)
        {
            node.getTarget().apply(this);
        }
        if(node.getParseProduction() != null)
        {
            node.getParseProduction().apply(this);
        }
        outAProductionParserTransition(node);
    }
}
