/* This file was generated by SableCC (http://www.sablecc.org/). */

package org.sablecc.sablecc.syntax3.analysis;

import java.util.*;
import org.sablecc.sablecc.syntax3.node.*;

public class DepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getPGrammar().apply(this);
        node.getEOF().apply(this);
        outStart(node);
    }

    public void inAGrammar(AGrammar node)
    {
        defaultIn(node);
    }

    public void outAGrammar(AGrammar node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGrammar(AGrammar node)
    {
        inAGrammar(node);
        if(node.getLanguageKeyword() != null)
        {
            node.getLanguageKeyword().apply(this);
        }
        if(node.getLanguageName() != null)
        {
            node.getLanguageName().apply(this);
        }
        if(node.getLexer() != null)
        {
            node.getLexer().apply(this);
        }
        if(node.getParser() != null)
        {
            node.getParser().apply(this);
        }
        if(node.getTransformation() != null)
        {
            node.getTransformation().apply(this);
        }
        if(node.getTree() != null)
        {
            node.getTree().apply(this);
        }
        outAGrammar(node);
    }

    public void inALexer(ALexer node)
    {
        defaultIn(node);
    }

    public void outALexer(ALexer node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexer(ALexer node)
    {
        inALexer(node);
        if(node.getLexerKeyword() != null)
        {
            node.getLexerKeyword().apply(this);
        }
        {
            List<PNamedExpression> copy = new ArrayList<PNamedExpression>(node.getNamedExpressions());
            for(PNamedExpression e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PGroup> copy = new ArrayList<PGroup>(node.getGroups());
            for(PGroup e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PLexerContext> copy = new ArrayList<PLexerContext>(node.getLexerContexts());
            for(PLexerContext e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PLexerInvestigator> copy = new ArrayList<PLexerInvestigator>(node.getLexerInvestigators());
            for(PLexerInvestigator e : copy)
            {
                e.apply(this);
            }
        }
        outALexer(node);
    }

    public void inANormalNamedExpression(ANormalNamedExpression node)
    {
        defaultIn(node);
    }

    public void outANormalNamedExpression(ANormalNamedExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANormalNamedExpression(ANormalNamedExpression node)
    {
        inANormalNamedExpression(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outANormalNamedExpression(node);
    }

    public void inASelectionNamedExpression(ASelectionNamedExpression node)
    {
        defaultIn(node);
    }

    public void outASelectionNamedExpression(ASelectionNamedExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASelectionNamedExpression(ASelectionNamedExpression node)
    {
        inASelectionNamedExpression(node);
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getNames());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        if(node.getSelectorName() != null)
        {
            node.getSelectorName().apply(this);
        }
        if(node.getParameter() != null)
        {
            node.getParameter().apply(this);
        }
        outASelectionNamedExpression(node);
    }

    public void inAOrExpression(AOrExpression node)
    {
        defaultIn(node);
    }

    public void outAOrExpression(AOrExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOrExpression(AOrExpression node)
    {
        inAOrExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getBar() != null)
        {
            node.getBar().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outAOrExpression(node);
    }

    public void inAConcatenationExpression(AConcatenationExpression node)
    {
        defaultIn(node);
    }

    public void outAConcatenationExpression(AConcatenationExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAConcatenationExpression(AConcatenationExpression node)
    {
        inAConcatenationExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outAConcatenationExpression(node);
    }

    public void inALookExpression(ALookExpression node)
    {
        defaultIn(node);
    }

    public void outALookExpression(ALookExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALookExpression(ALookExpression node)
    {
        inALookExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getLookKeyword() != null)
        {
            node.getLookKeyword().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outALookExpression(node);
    }

    public void inALookNotExpression(ALookNotExpression node)
    {
        defaultIn(node);
    }

    public void outALookNotExpression(ALookNotExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALookNotExpression(ALookNotExpression node)
    {
        inALookNotExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getLookKeyword() != null)
        {
            node.getLookKeyword().apply(this);
        }
        if(node.getNotKeyword() != null)
        {
            node.getNotKeyword().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outALookNotExpression(node);
    }

    public void inAShortestExpression(AShortestExpression node)
    {
        defaultIn(node);
    }

    public void outAShortestExpression(AShortestExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAShortestExpression(AShortestExpression node)
    {
        inAShortestExpression(node);
        if(node.getShortestKeyword() != null)
        {
            node.getShortestKeyword().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outAShortestExpression(node);
    }

    public void inALongestExpression(ALongestExpression node)
    {
        defaultIn(node);
    }

    public void outALongestExpression(ALongestExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALongestExpression(ALongestExpression node)
    {
        inALongestExpression(node);
        if(node.getLongestKeyword() != null)
        {
            node.getLongestKeyword().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        outALongestExpression(node);
    }

    public void inASubtractionExpression(ASubtractionExpression node)
    {
        defaultIn(node);
    }

    public void outASubtractionExpression(ASubtractionExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASubtractionExpression(ASubtractionExpression node)
    {
        inASubtractionExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getMinus() != null)
        {
            node.getMinus().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outASubtractionExpression(node);
    }

    public void inADifferenceExpression(ADifferenceExpression node)
    {
        defaultIn(node);
    }

    public void outADifferenceExpression(ADifferenceExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADifferenceExpression(ADifferenceExpression node)
    {
        inADifferenceExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getDiffKeyword() != null)
        {
            node.getDiffKeyword().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outADifferenceExpression(node);
    }

    public void inAAndExpression(AAndExpression node)
    {
        defaultIn(node);
    }

    public void outAAndExpression(AAndExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAndExpression(AAndExpression node)
    {
        inAAndExpression(node);
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        if(node.getAndKeyword() != null)
        {
            node.getAndKeyword().apply(this);
        }
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        outAAndExpression(node);
    }

    public void inAZeroOrOneExpression(AZeroOrOneExpression node)
    {
        defaultIn(node);
    }

    public void outAZeroOrOneExpression(AZeroOrOneExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAZeroOrOneExpression(AZeroOrOneExpression node)
    {
        inAZeroOrOneExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getQMark() != null)
        {
            node.getQMark().apply(this);
        }
        outAZeroOrOneExpression(node);
    }

    public void inAZeroOrMoreExpression(AZeroOrMoreExpression node)
    {
        defaultIn(node);
    }

    public void outAZeroOrMoreExpression(AZeroOrMoreExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAZeroOrMoreExpression(AZeroOrMoreExpression node)
    {
        inAZeroOrMoreExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getStar() != null)
        {
            node.getStar().apply(this);
        }
        outAZeroOrMoreExpression(node);
    }

    public void inASeparatedZeroOrMoreExpression(ASeparatedZeroOrMoreExpression node)
    {
        defaultIn(node);
    }

    public void outASeparatedZeroOrMoreExpression(ASeparatedZeroOrMoreExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedZeroOrMoreExpression(ASeparatedZeroOrMoreExpression node)
    {
        inASeparatedZeroOrMoreExpression(node);
        if(node.getBase() != null)
        {
            node.getBase().apply(this);
        }
        if(node.getSeparatorKeyword() != null)
        {
            node.getSeparatorKeyword().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getStar() != null)
        {
            node.getStar().apply(this);
        }
        outASeparatedZeroOrMoreExpression(node);
    }

    public void inAOneOrMoreExpression(AOneOrMoreExpression node)
    {
        defaultIn(node);
    }

    public void outAOneOrMoreExpression(AOneOrMoreExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOneOrMoreExpression(AOneOrMoreExpression node)
    {
        inAOneOrMoreExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getPlus() != null)
        {
            node.getPlus().apply(this);
        }
        outAOneOrMoreExpression(node);
    }

    public void inASeparatedOneOrMoreExpression(ASeparatedOneOrMoreExpression node)
    {
        defaultIn(node);
    }

    public void outASeparatedOneOrMoreExpression(ASeparatedOneOrMoreExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedOneOrMoreExpression(ASeparatedOneOrMoreExpression node)
    {
        inASeparatedOneOrMoreExpression(node);
        if(node.getBase() != null)
        {
            node.getBase().apply(this);
        }
        if(node.getSeparatorKeyword() != null)
        {
            node.getSeparatorKeyword().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getPlus() != null)
        {
            node.getPlus().apply(this);
        }
        outASeparatedOneOrMoreExpression(node);
    }

    public void inANumberExponentExpression(ANumberExponentExpression node)
    {
        defaultIn(node);
    }

    public void outANumberExponentExpression(ANumberExponentExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANumberExponentExpression(ANumberExponentExpression node)
    {
        inANumberExponentExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        outANumberExponentExpression(node);
    }

    public void inASeparatedNumberExponentExpression(ASeparatedNumberExponentExpression node)
    {
        defaultIn(node);
    }

    public void outASeparatedNumberExponentExpression(ASeparatedNumberExponentExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedNumberExponentExpression(ASeparatedNumberExponentExpression node)
    {
        inASeparatedNumberExponentExpression(node);
        if(node.getBase() != null)
        {
            node.getBase().apply(this);
        }
        if(node.getSeparatorKeyword() != null)
        {
            node.getSeparatorKeyword().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        outASeparatedNumberExponentExpression(node);
    }

    public void inAIntervalExponentExpression(AIntervalExponentExpression node)
    {
        defaultIn(node);
    }

    public void outAIntervalExponentExpression(AIntervalExponentExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntervalExponentExpression(AIntervalExponentExpression node)
    {
        inAIntervalExponentExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getTwoDots() != null)
        {
            node.getTwoDots().apply(this);
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        outAIntervalExponentExpression(node);
    }

    public void inASeparatedIntervalExponentExpression(ASeparatedIntervalExponentExpression node)
    {
        defaultIn(node);
    }

    public void outASeparatedIntervalExponentExpression(ASeparatedIntervalExponentExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedIntervalExponentExpression(ASeparatedIntervalExponentExpression node)
    {
        inASeparatedIntervalExponentExpression(node);
        if(node.getBase() != null)
        {
            node.getBase().apply(this);
        }
        if(node.getSeparatorKeyword() != null)
        {
            node.getSeparatorKeyword().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getTwoDots() != null)
        {
            node.getTwoDots().apply(this);
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        outASeparatedIntervalExponentExpression(node);
    }

    public void inAAtLeastExpression(AAtLeastExpression node)
    {
        defaultIn(node);
    }

    public void outAAtLeastExpression(AAtLeastExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAtLeastExpression(AAtLeastExpression node)
    {
        inAAtLeastExpression(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getThreeDots() != null)
        {
            node.getThreeDots().apply(this);
        }
        outAAtLeastExpression(node);
    }

    public void inASeparatedAtLeastExpression(ASeparatedAtLeastExpression node)
    {
        defaultIn(node);
    }

    public void outASeparatedAtLeastExpression(ASeparatedAtLeastExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedAtLeastExpression(ASeparatedAtLeastExpression node)
    {
        inASeparatedAtLeastExpression(node);
        if(node.getBase() != null)
        {
            node.getBase().apply(this);
        }
        if(node.getSeparatorKeyword() != null)
        {
            node.getSeparatorKeyword().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getThreeDots() != null)
        {
            node.getThreeDots().apply(this);
        }
        outASeparatedAtLeastExpression(node);
    }

    public void inANameExpression(ANameExpression node)
    {
        defaultIn(node);
    }

    public void outANameExpression(ANameExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANameExpression(ANameExpression node)
    {
        inANameExpression(node);
        if(node.getIdentifier() != null)
        {
            node.getIdentifier().apply(this);
        }
        outANameExpression(node);
    }

    public void inAStringExpression(AStringExpression node)
    {
        defaultIn(node);
    }

    public void outAStringExpression(AStringExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStringExpression(AStringExpression node)
    {
        inAStringExpression(node);
        if(node.getString() != null)
        {
            node.getString().apply(this);
        }
        outAStringExpression(node);
    }

    public void inACharExpression(ACharExpression node)
    {
        defaultIn(node);
    }

    public void outACharExpression(ACharExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACharExpression(ACharExpression node)
    {
        inACharExpression(node);
        if(node.getChar() != null)
        {
            node.getChar().apply(this);
        }
        outACharExpression(node);
    }

    public void inAEpsilonExpression(AEpsilonExpression node)
    {
        defaultIn(node);
    }

    public void outAEpsilonExpression(AEpsilonExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEpsilonExpression(AEpsilonExpression node)
    {
        inAEpsilonExpression(node);
        if(node.getEpsilon() != null)
        {
            node.getEpsilon().apply(this);
        }
        outAEpsilonExpression(node);
    }

    public void inADecExpression(ADecExpression node)
    {
        defaultIn(node);
    }

    public void outADecExpression(ADecExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADecExpression(ADecExpression node)
    {
        inADecExpression(node);
        if(node.getDecChar() != null)
        {
            node.getDecChar().apply(this);
        }
        outADecExpression(node);
    }

    public void inAHexExpression(AHexExpression node)
    {
        defaultIn(node);
    }

    public void outAHexExpression(AHexExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAHexExpression(AHexExpression node)
    {
        inAHexExpression(node);
        if(node.getHexChar() != null)
        {
            node.getHexChar().apply(this);
        }
        outAHexExpression(node);
    }

    public void inAIntervalExpression(AIntervalExpression node)
    {
        defaultIn(node);
    }

    public void outAIntervalExpression(AIntervalExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntervalExpression(AIntervalExpression node)
    {
        inAIntervalExpression(node);
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getTwoDots() != null)
        {
            node.getTwoDots().apply(this);
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        outAIntervalExpression(node);
    }

    public void inAAnyExpression(AAnyExpression node)
    {
        defaultIn(node);
    }

    public void outAAnyExpression(AAnyExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAnyExpression(AAnyExpression node)
    {
        inAAnyExpression(node);
        if(node.getAnyKeyword() != null)
        {
            node.getAnyKeyword().apply(this);
        }
        outAAnyExpression(node);
    }

    public void inAEndExpression(AEndExpression node)
    {
        defaultIn(node);
    }

    public void outAEndExpression(AEndExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEndExpression(AEndExpression node)
    {
        inAEndExpression(node);
        if(node.getEndKeyword() != null)
        {
            node.getEndKeyword().apply(this);
        }
        outAEndExpression(node);
    }

    public void inACharCharacter(ACharCharacter node)
    {
        defaultIn(node);
    }

    public void outACharCharacter(ACharCharacter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACharCharacter(ACharCharacter node)
    {
        inACharCharacter(node);
        if(node.getChar() != null)
        {
            node.getChar().apply(this);
        }
        outACharCharacter(node);
    }

    public void inADecCharacter(ADecCharacter node)
    {
        defaultIn(node);
    }

    public void outADecCharacter(ADecCharacter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADecCharacter(ADecCharacter node)
    {
        inADecCharacter(node);
        if(node.getDecChar() != null)
        {
            node.getDecChar().apply(this);
        }
        outADecCharacter(node);
    }

    public void inAHexCharacter(AHexCharacter node)
    {
        defaultIn(node);
    }

    public void outAHexCharacter(AHexCharacter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAHexCharacter(AHexCharacter node)
    {
        inAHexCharacter(node);
        if(node.getHexChar() != null)
        {
            node.getHexChar().apply(this);
        }
        outAHexCharacter(node);
    }

    public void inAGroup(AGroup node)
    {
        defaultIn(node);
    }

    public void outAGroup(AGroup node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGroup(AGroup node)
    {
        inAGroup(node);
        if(node.getGroupKeyword() != null)
        {
            node.getGroupKeyword().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getColon() != null)
        {
            node.getColon().apply(this);
        }
        {
            List<PUnit> copy = new ArrayList<PUnit>(node.getUnit());
            for(PUnit e : copy)
            {
                e.apply(this);
            }
        }
        outAGroup(node);
    }

    public void inANameUnit(ANameUnit node)
    {
        defaultIn(node);
    }

    public void outANameUnit(ANameUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANameUnit(ANameUnit node)
    {
        inANameUnit(node);
        if(node.getIdentifier() != null)
        {
            node.getIdentifier().apply(this);
        }
        outANameUnit(node);
    }

    public void inAStringUnit(AStringUnit node)
    {
        defaultIn(node);
    }

    public void outAStringUnit(AStringUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStringUnit(AStringUnit node)
    {
        inAStringUnit(node);
        if(node.getString() != null)
        {
            node.getString().apply(this);
        }
        outAStringUnit(node);
    }

    public void inACharacterUnit(ACharacterUnit node)
    {
        defaultIn(node);
    }

    public void outACharacterUnit(ACharacterUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACharacterUnit(ACharacterUnit node)
    {
        inACharacterUnit(node);
        if(node.getCharacter() != null)
        {
            node.getCharacter().apply(this);
        }
        outACharacterUnit(node);
    }

    public void inAEpsilonUnit(AEpsilonUnit node)
    {
        defaultIn(node);
    }

    public void outAEpsilonUnit(AEpsilonUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEpsilonUnit(AEpsilonUnit node)
    {
        inAEpsilonUnit(node);
        if(node.getEpsilon() != null)
        {
            node.getEpsilon().apply(this);
        }
        outAEpsilonUnit(node);
    }

    public void inAAnyUnit(AAnyUnit node)
    {
        defaultIn(node);
    }

    public void outAAnyUnit(AAnyUnit node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAnyUnit(AAnyUnit node)
    {
        inAAnyUnit(node);
        if(node.getAnyKeyword() != null)
        {
            node.getAnyKeyword().apply(this);
        }
        outAAnyUnit(node);
    }

    public void inALexerContext(ALexerContext node)
    {
        defaultIn(node);
    }

    public void outALexerContext(ALexerContext node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexerContext(ALexerContext node)
    {
        inALexerContext(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getTokens() != null)
        {
            node.getTokens().apply(this);
        }
        if(node.getIgnored() != null)
        {
            node.getIgnored().apply(this);
        }
        {
            List<PLexerPriority> copy = new ArrayList<PLexerPriority>(node.getLexerPriorities());
            for(PLexerPriority e : copy)
            {
                e.apply(this);
            }
        }
        outALexerContext(node);
    }

    public void inATokens(ATokens node)
    {
        defaultIn(node);
    }

    public void outATokens(ATokens node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokens(ATokens node)
    {
        inATokens(node);
        if(node.getTokenKeyword() != null)
        {
            node.getTokenKeyword().apply(this);
        }
        {
            List<PUnit> copy = new ArrayList<PUnit>(node.getUnit());
            for(PUnit e : copy)
            {
                e.apply(this);
            }
        }
        outATokens(node);
    }

    public void inAIgnored(AIgnored node)
    {
        defaultIn(node);
    }

    public void outAIgnored(AIgnored node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIgnored(AIgnored node)
    {
        inAIgnored(node);
        if(node.getIgnoredKeyword() != null)
        {
            node.getIgnoredKeyword().apply(this);
        }
        {
            List<PUnit> copy = new ArrayList<PUnit>(node.getUnit());
            for(PUnit e : copy)
            {
                e.apply(this);
            }
        }
        outAIgnored(node);
    }

    public void inALexerPriority(ALexerPriority node)
    {
        defaultIn(node);
    }

    public void outALexerPriority(ALexerPriority node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexerPriority(ALexerPriority node)
    {
        inALexerPriority(node);
        if(node.getHigh() != null)
        {
            node.getHigh().apply(this);
        }
        if(node.getGt() != null)
        {
            node.getGt().apply(this);
        }
        if(node.getLow() != null)
        {
            node.getLow().apply(this);
        }
        outALexerPriority(node);
    }

    public void inALexerInvestigator(ALexerInvestigator node)
    {
        defaultIn(node);
    }

    public void outALexerInvestigator(ALexerInvestigator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALexerInvestigator(ALexerInvestigator node)
    {
        inALexerInvestigator(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getParameter() != null)
        {
            node.getParameter().apply(this);
        }
        outALexerInvestigator(node);
    }

    public void inAParser(AParser node)
    {
        defaultIn(node);
    }

    public void outAParser(AParser node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParser(AParser node)
    {
        inAParser(node);
        if(node.getParserKeyword() != null)
        {
            node.getParserKeyword().apply(this);
        }
        if(node.getStart() != null)
        {
            node.getStart().apply(this);
        }
        if(node.getRestartable() != null)
        {
            node.getRestartable().apply(this);
        }
        {
            List<PParserContext> copy = new ArrayList<PParserContext>(node.getParserContexts());
            for(PParserContext e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getInlined() != null)
        {
            node.getInlined().apply(this);
        }
        outAParser(node);
    }

    public void inAStart(AStart node)
    {
        defaultIn(node);
    }

    public void outAStart(AStart node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStart(AStart node)
    {
        inAStart(node);
        if(node.getStartKeyword() != null)
        {
            node.getStartKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outAStart(node);
    }

    public void inARestartable(ARestartable node)
    {
        defaultIn(node);
    }

    public void outARestartable(ARestartable node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARestartable(ARestartable node)
    {
        inARestartable(node);
        if(node.getRestartableKeyword() != null)
        {
            node.getRestartableKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outARestartable(node);
    }

    public void inAParserContext(AParserContext node)
    {
        defaultIn(node);
    }

    public void outAParserContext(AParserContext node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserContext(AParserContext node)
    {
        inAParserContext(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        {
            List<PParserProduction> copy = new ArrayList<PParserProduction>(node.getParserProductions());
            for(PParserProduction e : copy)
            {
                e.apply(this);
            }
        }
        outAParserContext(node);
    }

    public void inANormalParserProduction(ANormalParserProduction node)
    {
        defaultIn(node);
    }

    public void outANormalParserProduction(ANormalParserProduction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANormalParserProduction(ANormalParserProduction node)
    {
        inANormalParserProduction(node);
        if(node.getQualifier() != null)
        {
            node.getQualifier().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        {
            List<PParserAlternative> copy = new ArrayList<PParserAlternative>(node.getParserAlternatives());
            for(PParserAlternative e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PParserPriority> copy = new ArrayList<PParserPriority>(node.getParserPriorities());
            for(PParserPriority e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getParserInvestigator() != null)
        {
            node.getParserInvestigator().apply(this);
        }
        outANormalParserProduction(node);
    }

    public void inASelectionParserProduction(ASelectionParserProduction node)
    {
        defaultIn(node);
    }

    public void outASelectionParserProduction(ASelectionParserProduction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASelectionParserProduction(ASelectionParserProduction node)
    {
        inASelectionParserProduction(node);
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getNames());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        if(node.getSelectorName() != null)
        {
            node.getSelectorName().apply(this);
        }
        if(node.getParameter() != null)
        {
            node.getParameter().apply(this);
        }
        outASelectionParserProduction(node);
    }

    public void inADanglingQualifier(ADanglingQualifier node)
    {
        defaultIn(node);
    }

    public void outADanglingQualifier(ADanglingQualifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADanglingQualifier(ADanglingQualifier node)
    {
        inADanglingQualifier(node);
        if(node.getDanglingKeyword() != null)
        {
            node.getDanglingKeyword().apply(this);
        }
        outADanglingQualifier(node);
    }

    public void inATokenQualifier(ATokenQualifier node)
    {
        defaultIn(node);
    }

    public void outATokenQualifier(ATokenQualifier node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATokenQualifier(ATokenQualifier node)
    {
        inATokenQualifier(node);
        if(node.getTokenKeyword() != null)
        {
            node.getTokenKeyword().apply(this);
        }
        outATokenQualifier(node);
    }

    public void inAParserAlternative(AParserAlternative node)
    {
        defaultIn(node);
    }

    public void outAParserAlternative(AParserAlternative node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserAlternative(AParserAlternative node)
    {
        inAParserAlternative(node);
        if(node.getAlternativeName() != null)
        {
            node.getAlternativeName().apply(this);
        }
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getDanglingElement() != null)
        {
            node.getDanglingElement().apply(this);
        }
        outAParserAlternative(node);
    }

    public void inAUnitElement(AUnitElement node)
    {
        defaultIn(node);
    }

    public void outAUnitElement(AUnitElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAUnitElement(AUnitElement node)
    {
        inAUnitElement(node);
        if(node.getElementName() != null)
        {
            node.getElementName().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        if(node.getUnaryOperator() != null)
        {
            node.getUnaryOperator().apply(this);
        }
        outAUnitElement(node);
    }

    public void inASeparatedElement(ASeparatedElement node)
    {
        defaultIn(node);
    }

    public void outASeparatedElement(ASeparatedElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASeparatedElement(ASeparatedElement node)
    {
        inASeparatedElement(node);
        if(node.getElementName() != null)
        {
            node.getElementName().apply(this);
        }
        if(node.getUnit() != null)
        {
            node.getUnit().apply(this);
        }
        if(node.getSeparatorKeyword() != null)
        {
            node.getSeparatorKeyword().apply(this);
        }
        if(node.getSeparator() != null)
        {
            node.getSeparator().apply(this);
        }
        if(node.getManyOperator() != null)
        {
            node.getManyOperator().apply(this);
        }
        outASeparatedElement(node);
    }

    public void inAZeroOrOneUnaryOperator(AZeroOrOneUnaryOperator node)
    {
        defaultIn(node);
    }

    public void outAZeroOrOneUnaryOperator(AZeroOrOneUnaryOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAZeroOrOneUnaryOperator(AZeroOrOneUnaryOperator node)
    {
        inAZeroOrOneUnaryOperator(node);
        if(node.getQMark() != null)
        {
            node.getQMark().apply(this);
        }
        outAZeroOrOneUnaryOperator(node);
    }

    public void inAManyUnaryOperator(AManyUnaryOperator node)
    {
        defaultIn(node);
    }

    public void outAManyUnaryOperator(AManyUnaryOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAManyUnaryOperator(AManyUnaryOperator node)
    {
        inAManyUnaryOperator(node);
        if(node.getManyOperator() != null)
        {
            node.getManyOperator().apply(this);
        }
        outAManyUnaryOperator(node);
    }

    public void inAZeroOrMoreManyOperator(AZeroOrMoreManyOperator node)
    {
        defaultIn(node);
    }

    public void outAZeroOrMoreManyOperator(AZeroOrMoreManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAZeroOrMoreManyOperator(AZeroOrMoreManyOperator node)
    {
        inAZeroOrMoreManyOperator(node);
        if(node.getStar() != null)
        {
            node.getStar().apply(this);
        }
        outAZeroOrMoreManyOperator(node);
    }

    public void inAOneOrMoreManyOperator(AOneOrMoreManyOperator node)
    {
        defaultIn(node);
    }

    public void outAOneOrMoreManyOperator(AOneOrMoreManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOneOrMoreManyOperator(AOneOrMoreManyOperator node)
    {
        inAOneOrMoreManyOperator(node);
        if(node.getPlus() != null)
        {
            node.getPlus().apply(this);
        }
        outAOneOrMoreManyOperator(node);
    }

    public void inANumberManyOperator(ANumberManyOperator node)
    {
        defaultIn(node);
    }

    public void outANumberManyOperator(ANumberManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANumberManyOperator(ANumberManyOperator node)
    {
        inANumberManyOperator(node);
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        outANumberManyOperator(node);
    }

    public void inAIntervalManyOperator(AIntervalManyOperator node)
    {
        defaultIn(node);
    }

    public void outAIntervalManyOperator(AIntervalManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntervalManyOperator(AIntervalManyOperator node)
    {
        inAIntervalManyOperator(node);
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        if(node.getFrom() != null)
        {
            node.getFrom().apply(this);
        }
        if(node.getTwoDots() != null)
        {
            node.getTwoDots().apply(this);
        }
        if(node.getTo() != null)
        {
            node.getTo().apply(this);
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outAIntervalManyOperator(node);
    }

    public void inAAtLeastManyOperator(AAtLeastManyOperator node)
    {
        defaultIn(node);
    }

    public void outAAtLeastManyOperator(AAtLeastManyOperator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAtLeastManyOperator(AAtLeastManyOperator node)
    {
        inAAtLeastManyOperator(node);
        if(node.getCaret() != null)
        {
            node.getCaret().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        if(node.getThreeDots() != null)
        {
            node.getThreeDots().apply(this);
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outAAtLeastManyOperator(node);
    }

    public void inADanglingElement(ADanglingElement node)
    {
        defaultIn(node);
    }

    public void outADanglingElement(ADanglingElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADanglingElement(ADanglingElement node)
    {
        inADanglingElement(node);
        if(node.getDanglingKeyword() != null)
        {
            node.getDanglingKeyword().apply(this);
        }
        if(node.getElementName() != null)
        {
            node.getElementName().apply(this);
        }
        if(node.getIdentifier() != null)
        {
            node.getIdentifier().apply(this);
        }
        if(node.getQMark() != null)
        {
            node.getQMark().apply(this);
        }
        outADanglingElement(node);
    }

    public void inALeftParserPriority(ALeftParserPriority node)
    {
        defaultIn(node);
    }

    public void outALeftParserPriority(ALeftParserPriority node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALeftParserPriority(ALeftParserPriority node)
    {
        inALeftParserPriority(node);
        if(node.getLeftKeyword() != null)
        {
            node.getLeftKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outALeftParserPriority(node);
    }

    public void inARightParserPriority(ARightParserPriority node)
    {
        defaultIn(node);
    }

    public void outARightParserPriority(ARightParserPriority node)
    {
        defaultOut(node);
    }

    @Override
    public void caseARightParserPriority(ARightParserPriority node)
    {
        inARightParserPriority(node);
        if(node.getRightKeyword() != null)
        {
            node.getRightKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outARightParserPriority(node);
    }

    public void inAParserInvestigator(AParserInvestigator node)
    {
        defaultIn(node);
    }

    public void outAParserInvestigator(AParserInvestigator node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAParserInvestigator(AParserInvestigator node)
    {
        inAParserInvestigator(node);
        if(node.getInvestigatorKeyword() != null)
        {
            node.getInvestigatorKeyword().apply(this);
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getParameters());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outAParserInvestigator(node);
    }

    public void inAInlined(AInlined node)
    {
        defaultIn(node);
    }

    public void outAInlined(AInlined node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAInlined(AInlined node)
    {
        inAInlined(node);
        if(node.getInlinedKeyword() != null)
        {
            node.getInlinedKeyword().apply(this);
        }
        {
            List<TIdentifier> copy = new ArrayList<TIdentifier>(node.getIdentifiers());
            for(TIdentifier e : copy)
            {
                e.apply(this);
            }
        }
        outAInlined(node);
    }

    public void inATransformation(ATransformation node)
    {
        defaultIn(node);
    }

    public void outATransformation(ATransformation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATransformation(ATransformation node)
    {
        inATransformation(node);
        if(node.getTransformationKeyword() != null)
        {
            node.getTransformationKeyword().apply(this);
        }
        if(node.getProductionTransformations() != null)
        {
            node.getProductionTransformations().apply(this);
        }
        if(node.getAlternativeTransformations() != null)
        {
            node.getAlternativeTransformations().apply(this);
        }
        outATransformation(node);
    }

    public void inAProductionTransformations(AProductionTransformations node)
    {
        defaultIn(node);
    }

    public void outAProductionTransformations(AProductionTransformations node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProductionTransformations(AProductionTransformations node)
    {
        inAProductionTransformations(node);
        if(node.getProductionKeyword() != null)
        {
            node.getProductionKeyword().apply(this);
        }
        {
            List<PProductionTransformation> copy = new ArrayList<PProductionTransformation>(node.getProductionTransformations());
            for(PProductionTransformation e : copy)
            {
                e.apply(this);
            }
        }
        outAProductionTransformations(node);
    }

    public void inAProductionTransformation(AProductionTransformation node)
    {
        defaultIn(node);
    }

    public void outAProductionTransformation(AProductionTransformation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProductionTransformation(AProductionTransformation node)
    {
        inAProductionTransformation(node);
        if(node.getProduction() != null)
        {
            node.getProduction().apply(this);
        }
        if(node.getArrow() != null)
        {
            node.getArrow().apply(this);
        }
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        outAProductionTransformation(node);
    }

    public void inAAlternativeTransformations(AAlternativeTransformations node)
    {
        defaultIn(node);
    }

    public void outAAlternativeTransformations(AAlternativeTransformations node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAlternativeTransformations(AAlternativeTransformations node)
    {
        inAAlternativeTransformations(node);
        if(node.getAlternativeKeyword() != null)
        {
            node.getAlternativeKeyword().apply(this);
        }
        {
            List<PAlternativeTransformation> copy = new ArrayList<PAlternativeTransformation>(node.getAlternativeTransformations());
            for(PAlternativeTransformation e : copy)
            {
                e.apply(this);
            }
        }
        outAAlternativeTransformations(node);
    }

    public void inAAlternativeTransformation(AAlternativeTransformation node)
    {
        defaultIn(node);
    }

    public void outAAlternativeTransformation(AAlternativeTransformation node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAlternativeTransformation(AAlternativeTransformation node)
    {
        inAAlternativeTransformation(node);
        if(node.getAlternativeReference() != null)
        {
            node.getAlternativeReference().apply(this);
        }
        if(node.getArrow() != null)
        {
            node.getArrow().apply(this);
        }
        {
            List<PTransformationElement> copy = new ArrayList<PTransformationElement>(node.getTransformationElements());
            for(PTransformationElement e : copy)
            {
                e.apply(this);
            }
        }
        outAAlternativeTransformation(node);
    }

    public void inAUnnamedAlternativeReference(AUnnamedAlternativeReference node)
    {
        defaultIn(node);
    }

    public void outAUnnamedAlternativeReference(AUnnamedAlternativeReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAUnnamedAlternativeReference(AUnnamedAlternativeReference node)
    {
        inAUnnamedAlternativeReference(node);
        if(node.getProduction() != null)
        {
            node.getProduction().apply(this);
        }
        outAUnnamedAlternativeReference(node);
    }

    public void inANamedAlternativeReference(ANamedAlternativeReference node)
    {
        defaultIn(node);
    }

    public void outANamedAlternativeReference(ANamedAlternativeReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANamedAlternativeReference(ANamedAlternativeReference node)
    {
        inANamedAlternativeReference(node);
        if(node.getProduction() != null)
        {
            node.getProduction().apply(this);
        }
        if(node.getDot() != null)
        {
            node.getDot().apply(this);
        }
        if(node.getAlternative() != null)
        {
            node.getAlternative().apply(this);
        }
        outANamedAlternativeReference(node);
    }

    public void inANullTransformationElement(ANullTransformationElement node)
    {
        defaultIn(node);
    }

    public void outANullTransformationElement(ANullTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANullTransformationElement(ANullTransformationElement node)
    {
        inANullTransformationElement(node);
        if(node.getNullKeyword() != null)
        {
            node.getNullKeyword().apply(this);
        }
        outANullTransformationElement(node);
    }

    public void inAReferenceTransformationElement(AReferenceTransformationElement node)
    {
        defaultIn(node);
    }

    public void outAReferenceTransformationElement(AReferenceTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReferenceTransformationElement(AReferenceTransformationElement node)
    {
        inAReferenceTransformationElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        outAReferenceTransformationElement(node);
    }

    public void inANewTransformationElement(ANewTransformationElement node)
    {
        defaultIn(node);
    }

    public void outANewTransformationElement(ANewTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANewTransformationElement(ANewTransformationElement node)
    {
        inANewTransformationElement(node);
        if(node.getNewKeyword() != null)
        {
            node.getNewKeyword().apply(this);
        }
        if(node.getAlternativeReference() != null)
        {
            node.getAlternativeReference().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        {
            List<PTransformationElement> copy = new ArrayList<PTransformationElement>(node.getTransformationElements());
            for(PTransformationElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outANewTransformationElement(node);
    }

    public void inAListTransformationElement(AListTransformationElement node)
    {
        defaultIn(node);
    }

    public void outAListTransformationElement(AListTransformationElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAListTransformationElement(AListTransformationElement node)
    {
        inAListTransformationElement(node);
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        {
            List<PListElement> copy = new ArrayList<PListElement>(node.getListElements());
            for(PListElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outAListTransformationElement(node);
    }

    public void inAReferenceListElement(AReferenceListElement node)
    {
        defaultIn(node);
    }

    public void outAReferenceListElement(AReferenceListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReferenceListElement(AReferenceListElement node)
    {
        inAReferenceListElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        outAReferenceListElement(node);
    }

    public void inAListReferenceListElement(AListReferenceListElement node)
    {
        defaultIn(node);
    }

    public void outAListReferenceListElement(AListReferenceListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAListReferenceListElement(AListReferenceListElement node)
    {
        inAListReferenceListElement(node);
        if(node.getElementReference() != null)
        {
            node.getElementReference().apply(this);
        }
        if(node.getThreeDots() != null)
        {
            node.getThreeDots().apply(this);
        }
        outAListReferenceListElement(node);
    }

    public void inANewListElement(ANewListElement node)
    {
        defaultIn(node);
    }

    public void outANewListElement(ANewListElement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANewListElement(ANewListElement node)
    {
        inANewListElement(node);
        if(node.getNewKeyword() != null)
        {
            node.getNewKeyword().apply(this);
        }
        if(node.getAlternativeReference() != null)
        {
            node.getAlternativeReference().apply(this);
        }
        if(node.getLPar() != null)
        {
            node.getLPar().apply(this);
        }
        {
            List<PTransformationElement> copy = new ArrayList<PTransformationElement>(node.getTransformationElements());
            for(PTransformationElement e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRPar() != null)
        {
            node.getRPar().apply(this);
        }
        outANewListElement(node);
    }

    public void inANaturalElementReference(ANaturalElementReference node)
    {
        defaultIn(node);
    }

    public void outANaturalElementReference(ANaturalElementReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANaturalElementReference(ANaturalElementReference node)
    {
        inANaturalElementReference(node);
        if(node.getElement() != null)
        {
            node.getElement().apply(this);
        }
        outANaturalElementReference(node);
    }

    public void inATransformedElementReference(ATransformedElementReference node)
    {
        defaultIn(node);
    }

    public void outATransformedElementReference(ATransformedElementReference node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATransformedElementReference(ATransformedElementReference node)
    {
        inATransformedElementReference(node);
        if(node.getElement() != null)
        {
            node.getElement().apply(this);
        }
        if(node.getDot() != null)
        {
            node.getDot().apply(this);
        }
        if(node.getPart() != null)
        {
            node.getPart().apply(this);
        }
        outATransformedElementReference(node);
    }

    public void inATree(ATree node)
    {
        defaultIn(node);
    }

    public void outATree(ATree node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATree(ATree node)
    {
        inATree(node);
        if(node.getTreeKeyword() != null)
        {
            node.getTreeKeyword().apply(this);
        }
        {
            List<PTreeProduction> copy = new ArrayList<PTreeProduction>(node.getTreeProductions());
            for(PTreeProduction e : copy)
            {
                e.apply(this);
            }
        }
        outATree(node);
    }

    public void inATreeProduction(ATreeProduction node)
    {
        defaultIn(node);
    }

    public void outATreeProduction(ATreeProduction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATreeProduction(ATreeProduction node)
    {
        inATreeProduction(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        if(node.getAssign() != null)
        {
            node.getAssign().apply(this);
        }
        {
            List<PTreeAlternative> copy = new ArrayList<PTreeAlternative>(node.getTreeAlternatives());
            for(PTreeAlternative e : copy)
            {
                e.apply(this);
            }
        }
        outATreeProduction(node);
    }

    public void inATreeAlternative(ATreeAlternative node)
    {
        defaultIn(node);
    }

    public void outATreeAlternative(ATreeAlternative node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATreeAlternative(ATreeAlternative node)
    {
        inATreeAlternative(node);
        if(node.getAlternativeName() != null)
        {
            node.getAlternativeName().apply(this);
        }
        {
            List<PElement> copy = new ArrayList<PElement>(node.getElements());
            for(PElement e : copy)
            {
                e.apply(this);
            }
        }
        outATreeAlternative(node);
    }
}
